<div id="home">
<center>
<a href="#overview">Overview</a>
<a href="#requirements">Requirements</a>
<a href="#install">Installation</a>
<a href="#layout">System Layout</a>
<a href="#cli">Command Line</a>
<a href="#server">Server</a>
<a href="#gui">Accessing the GUI</a>
<a href="#gui-use">Using the GUI</a>
<a href="#admin">Admin Interface</a>
<a href="#database">Database Structure</a>
</center>
</div>

<br>

<div id="overview">
<b>Overview</b>&nbsp;<a href="#home">Top</a>
<p>
The Linux Foundation deps-checker is a tool to explore linkage dependencies of binaries
and libraries built with FOSS components.<br> 
The system consists of 2 pieces, a command-line program 
"readelf.py" and a GUI frontend that runs in a web browser. 
</p>

<div id="requirements">
<b>System Requirements</b>&nbsp;<a href="#home">Top</a>
<p>
The command-line program and the GUI require python. It also runs the OS commands: 
<i>file, ldd, readelf</i>, so these should be present on your system.
The GUI requires <a href="http://www.djangoproject.com">Django</a>, along with sqlite 
support for the results database.
</p>

<div id="install">
<b>Installation</b>&nbsp;<a href="#home">Top</a>
<p>
The program is packaged as an rpm package, with dependencies on python-django. If your 
system does not provide django, or it's named differently, you may need to install using
--nodeps:

<pre>
rpm -Uvh deps-checker-0.0.2-1.noarch.rpm --nodeps
</pre>

The installation creates a "compliance" user/group and should create a desktop menu entry
to launch the server and open the GUI in your web browser.
</p>

<p>
In the future we may bundle django with the package to make things simpler, as well as 
provide .deb packaging.
</p>

<div id="layout">
<b>System Layout</b>&nbsp;<a href="#home">Top</a>
<p>
The application installs under the <i>/opt/linuxfoundation</i> namespace:

<ul>
<li><b>bin</b> - command line program and wrapper script to launch gui</li>
<li><b>compliance</b> - gui application tree and results database</li>
<li><b>doc</b> - License file</li>
<li><b>share</b> - Desktop menu files and icons</li>
</ul>

Under the compliance tree, is a typical django project layout:

<ul>
<li><b>compliance</b> - sqlite results database</b>
<li><b>__init__.py, manage.py, settings.py, urls.py</b> - generated by django at project 
    creation, <i>settings.py</i> does have some configurable settings. None of the others should 
    be altered.</li>
<li><b>linkage</b> - deps-checker GUI code</li>
<li><b>media</b> - static html elements such as images, css, javascript files</li>
<li><b>templates/linkage</b> - the deps-checker html tree</li>
</ul>

<div id="cli">
<b>Running the command line program</b>&nbsp;<a href="#home">Top</a>
<p>The command line program is called <i>readelf.py</i>, and it resides in 
<i>/opt/linuxfoundation/bin</i>:

<pre>
$ /opt/linuxfoundation/bin/readelf.py -?
/opt/linuxfoundation/bin/readelf.py version 0.0.4
Usage:  
       -c output in csv format
       -s &lt;directory tree to search&gt;
       &lt;directory tree or file to examine&gt; [recursion depth]
       Specifying a directory without -s will report all ELF
       files in that directory tree
</pre>

The <i>-c</i> option is primarily used to pass data to the GUI. The format without this
argument is more human-readable if you are using the command line directly.

<p>
The <i>-s</i> option expects a directory as an argument. If you specify this option, the
program will attempt to drill down through the directory mentioned to find only files
with the name specified by the next argument to analyse:

<pre>
/opt/linuxfoundation/bin/readelf.py -s /foo bar
</pre>

The program will search everything under <i>/foo</i>, for ELF files named <i>bar</i>
</p>

<p>Specifying only a directory will search and report on <i>every</i> ELF file in that
directory tree:

<pre>
/opt/linuxfoundation/bin/readelf.py /foo
</pre>

Specifying only a file will attempt to test only the specified file:

<pre>
/opt/linuxfoundation/bin/readelf.py /foo/bar/baz
</pre>

The recursion level is an optional argument, that will attempt to not only report the
<i>direct</i> dependencies, but also report the dependencies of each library used by
the target file:

<pre>
/opt/linuxfoundation/bin/readelf.py /foo/bar/baz 4
</pre>

This would attempt to recurse down 4 levels from the target file, giving output something 
like this:

<pre>
[1]/foo/bar/baz:
  libtermcap.so.2
  [2]/lib/libtermcap.so.2.0.8:
    libc.so.6
    [3]/lib/i686/libc-2.10.1.so:
      ld-linux.so.2
[1]/foo/bar/baz:
  libdl.so.2
  [2]/lib/libdl-2.10.1.so:
    libc.so.6
    ld-linux.so.2
    [3]/lib/i686/libc-2.10.1.so:
      ld-linux.so.2
[1]/foo/bar/baz:
  libc.so.6
  [2]/lib/i686/libc-2.10.1.so:
    ld-linux.so.2
</pre>

You will note that even though we asked for a recursion level of 4, the test stopped at 
level 3, as the program detects when no further recursion is possible.
</p>

<div id="server">
<b>Running the GUI server</b>&nbsp;<a href="#home">Top</a>
<p>
To run the gui/server (as user compliance for installed package), there is a shell
script that su's to the compliance user, starts the server and attempts to open a browser
page to the GUI:

<pre>
/opt/linuxfoundation/bin/deps-checker.sh
</pre>

There is no facility at this time to stop the server.
</p>
<p>
If for some reason this does not work, you can manually perform the steps to start the
 server:

<pre>
su - compliance
cd /opt/linuxfoundation/compliance
python manage.py runserver
</pre>

You can terminate the server from this console by hitting ctrl-C
</p>

<div id="gui">
<b>Accessing the GUI</b>&nbsp;<a href="#home">Top</a>
<p>
If a browser does not open by launching the menu item, you can access the GUI 
(once the server is started): at 
<a href="http://127.0.0.1:8000/linkage" target="_blank">http://127.0.0.1:8000/linkage</a>.
</p>

<div id="gui-use">
<b>Using the GUI</b>&nbsp;<a href="#home">Top</a>

<p>The GUI interface is pretty straighforward, with 5 tabs to access various aspects of
program:

<ul>
<li><b>Home</b> - Top level page</li>
<li><b>Test</b> - Test entry, initiate form</li>
<li><b>Results</b> - Tabular list of existing test results</li>
<li><b>About</B> - An "about" page with license info</li>
<li><b>Documentation</b> - This documentation</li>
</ul>

The final page, which isn't visible in the tabs, is the test results detail page, 
brought up by either running a test, or clicking on the link in the results page.
</p>

<p>A test sequence would typical start at the <b>Test</b> page, where you enter the test
criteria. This setup parallels the operation of the command line program, where you
select whether to search for a file under a directory, test a whole directory, or just 
a single file. There is also a drop-down to select the recursion level.</p>

<p>The <i>user</i> field is pre-populated with the <i>compliance</i> user, but can be
overridden. The <i>project</i> and <i>comments</i> fields are optional for your use in
tracking tests.</p>

<p>Once you enter the test criteria, click on the <b>Run Test</b> button. After the test
runs you will be presented with the detailed test results in tabular form. Depending on
the number of files to be tested and the recusion level, the test can take a few minutes,
so be patient.</p>

<p>The test results should also be accessible from the <b>Results</b> page. If you want
to delete test results, you can select and delete them from here</b>
 
<div id="admin">
<b>Accessing the admin interface</b>&nbsp;<a href="#home">Top</a>

<p>In the current configuration, the django admin interface is enabled. While
you can use this interface to directly access the database records, one should
take care not to alter existing records, except in the case of wishing to add
license information to records.

<br>
<b>admin interface:</b> <a href="http://127.0.0.1:8000/admin" target="_blank">http://127.0.0.1:8000/admin</a>
(username compliance, password compliance)
</p>

<div id="database">
<b>Database Structure</b>&nbsp;<a href="#home">Top</a>

<p>There are basically 3 tables that are used by the application in <i>compliance</i>
database:</p>

<ul>
<li><b>linkage_test</b> - Test summary data</li>
<li><b>linkage_file</b> - Test record for each target file tested. <i>child</i> files from
recursion are also stored here, but not currently used in reporting</li>
<li><b>linkage_lib</b> - Test record for each library dependency</li>
</ul>

Both the <b>file</b> and <b>lib</b> tables have <i>license</i> fields which can be populated
with license data using normal SQL tools to access the sqlite data. A simple example would
be something like:

<pre>
su - compliance
sqlite3 /opt/linuxfoundation/compliance/compliance
sqlite> update linkage_lib set license = "GPLv3" where library = "libc.so.6";
ctrl-D
</pre>

This could of course be automated with some scripts, perhaps driven by a cron job.

